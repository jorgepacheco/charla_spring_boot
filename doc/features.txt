
=================
SpringApplication
=================

. SpringApplication clase encargada de arrancar una aplicación Spring.

public static void main(String[] args) {
    SpringApplication.run(MySpringConfiguration.class, args);
}

. Al arrancar se muestra en consola algo asi

				.   ____          _            __ _ _
				 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
				( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
				 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
				  '  |____| .__|_| |_|_| |_\__, | / / / /
				 =========|_|==============|___/=/_/_/_/
				 :: Spring Boot ::   v1.2.0.BUILD-SNAPSHOT

				2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
				2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
				2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatEmbeddedServletContainerFactory : Server initialized with port: 8080
				2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication 

. Esto es customizable --> Se puede añadir un banner.txt en el classpath o indicar la ubicación co la propiedad banner.location
. O desactivarlo

public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setShowBanner(false);
    app.run(args);
}

. Tiene la referencia de las @Configuration clases, pueden ser ficheros de configuración o packetes a escanear.

. Se le pueden añadir Application events and listeners

. Crea el aplicationContext adecuado AnnotationConfigApplicationContext or AnnotationConfigEmbeddedWebApplicationContext en funcion de si es un entrono web o no. (Se puede desactivar el contexto WEB setWebEnvironment(boolean webEnvironment) --> Por ejemplo para Test

. Se puede añadir un aplicationContext propio setApplicationContextClass

. Si necessitamos ejecutar algu codigo cuando arranque SprinApplication, los beans pueden extender de CommandLineRunner

	@Component
	public class MyBean implements CommandLineRunner {

	    public void run(String... args) {
	        // Do something...
	    }

	}

. Application exit

	Implementar org.springframework.boot.ExitCodeGenerator interface


=============================
EXternalizar la Configuracion
=============================


. Spring Boot le permite externalizar su configuración para que pueda trabajar con el mismo código de la aplicación en diferentes entornos. 

	- Puede utilizar archivos de propiedades, 
	- archivos YAML, 
	- variables de entorno 
	- Argumentos de línea de comandos para exteriorizar configuración. 

. Los valores de propiedad pueden ser inyectados directamente @Value


. EL orden que sigue Spring Boot sigue para resolver 

		- Command line arguments.
		- Java System properties (System.getProperties()).
		- OS environment variables.
		- JNDI attributes from java:comp/env
		- A RandomValuePropertySource that only has properties in random.*.
		- Application properties outside of your packaged jar (application.properties including YAML and profile variants).
		- Application properties packaged inside your jar (application.properties including YAML and profile variants).
		- @PropertySource annotations on your @Configuration classes.
		- Default properties (specified using SpringApplication.setDefaultProperties).

Ej:

		@Component
		public class MyBean {

		    @Value("${name}")
		    private String name;

		    // ...

		}

	1. Añadir la propiedad name en un fichero application.properties en el classpath
		A /config subdir of the current directory.
		The current directory
		A classpath /config package
		The classpath root

	2. Se puede sobreescribir añadiendo el valor por liena de comando java -jar app.jar --name="Spring"

	3. RandomValuePropertySource para generar valores aleatorios --> Para Test

		my.secret=${random.value}
		my.number=${random.int}
		my.bignumber=${random.long}
		my.number.less.than.ten=${random.int(10)}
		my.number.in.range=${random.int[1024,65536]}


	Si no qwueremos que el fichero no se llame application.properties, deberemos  definir la propiedad spring.config.name

	Si queremos cambiar la ubicacion del archivo spring.config.location

	java -jar target/external-configuration-spring-boot-0.0.1-SNAPSHOT.jar --spring.config.location=file:/Users/jorgepacheco/configSpringBoot/application.properties

	Un uso comun es usar el application.properties y en el definir spring.config.name y spring.config.location


	-  Profile specific properties ==> application-{profile}.properties

	- Placeholders in properties ==> 
										app.name=MyApp
										app.description=${app.name} is a Spring Boot application


. TAmbien soporta el formato YAML para definir las propiedades

. CUando esta activado @EnableConfigurationProperties Los bean anotados @ConfigurationProperties will be automatically configured from the Environment properties

@Component
@ConfigurationProperties(prefix="connection")
public class ConnectionSettings {

    private String username;

    private InetAddress remoteAddress;

    // ... getters and setters

}

Util con el formato YAML

# application.yml

connection:
    username: admin
    remoteAddress: 192.168.1.1

# additional configuration as required


O .properties   connection.username= admin
				connection.remoteAddress=192.168.1.1


It is also possible to shortcut the registration of @ConfigurationProperties bean definitions by simply listing the properties classes directly in the @EnableConfigurationProperties annotation:

- @ConfigurationProperties se le pueden añadir validaciones JSR-303

@Component
@ConfigurationProperties(prefix="connection")
public class ConnectionSettings {

    @NotNull
    private InetAddress remoteAddress;

    // ... getters and setters

}

- Incluso se pueden añadir Validator personalizado de Spring ==> creating a bean definition called configurationPropertiesValidator



=========
PROFILES
=========

@Configuration
@Profile("production")
public class ProductionConfiguration {

    // ...

}


spring.profiles.active se activa el profile a usar --> desde el aplication.properties --> spring.profiles.active=dev,hsqldb
o desde linea de comando --spring.profiles.active=dev,hsqldb

spring.profiles.include --> añade mas perfiles al activo

Ej:

spring.profiles: prod
spring.profiles.include: proddb,prodmq

Cuando se activa --spring.profiles.active = prod se activan los perfiles proddb, prodmq

Se pueden activar programaticamente SpringApplication.setAdditionalProfiles(...) antes de que arranque la aplicacion
. It is also possible to activate profiles using Spring’s ConfigurableEnvironment interface.

========
LOGGING
========

. Spring Boot usa internamete Commons Logging

. Si usas las Starter POMs Logback


. The default log configuration will echo messages to the console as they are written. By default ERROR, WARN and INFO level messages are logged. To also log DEBUG level messages to the console you can start your application with a --debug flag.


. Por defecto el Log va por pantalla y con nivel ERROR, WARN and INFO para cambiarlo puedes añadir el flag --debug

. Para definir el nombre del fichero de log en el application.properties se añade el parametro logging.file o logging.path

. Se puede dsefinir el nivel de log añadiendo al application.properties

		logging.level.org.springframework.web= DEBUG
		logging.level.org.hibernate= ERROR

. Se pueden personalizar el sistema de trazas añadiendo las dependencias necesarias y añadiendo el fichero de congiguracion apropiado
al classpath (o donde le indiquemos con logging.config) --> Revisar ejemplo

		Logback --> logback.xml

		Log4j --> log4j.properties or log4j.xml

		JDK (Java Util Logging) --> logging.properties


================
WEB APPLICATIONS
================

. Spring Boot - Permite arrancar de manera facil y rapida aplicaciones web
. Ofrece la posibilidad de crear un servidor embebido como Tomcat y Jetty
. spring-boot-starter-web


Spring MVC auto-configuration

 - Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
 - Support for serving static resources, including support for WebJars (see below).
 - Automatic registration of Converter, GenericConverter, Formatter beans.
 - Support for HttpMessageConverters (see below).
 - Automatic registration of MessageCodeResolver (see below)
 - Static index.html support.
 - Custom Favicon support.

. Si se quiere tener el control completo de Spring MVC se añade un bean @Configuration con @EnableWebMvc

. Si se quiere mantener la configuración de Spring MVC Boot y añadir configuración adicional se puede añadir su propio @Bean de tipo 
WebMvcConfigurerAdapter, pero sin @EnableWebMvc 


@Configuration
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter<?> additional = ...
        HttpMessageConverter<?> another = ...
        return new HttpMessageConverters(additional, another);
    }

}


Añade un custom Converter


* Contenido estatico

Por defecto /static (or /public or /resources or /META-INF/resources

Any resources with a path in /webjars/**

ESte comportamiento se puede personalizar usando WebMvcConfigurerAdapter and overriding the addResourceHandlers

* Template Engine (Por defecto ThymeLeaf)


	- FreeMarker
	- Groovy
	- Thymeleaf
	- Velocity

Los template los busca en /main/resources/templates.

* 24.1.6 Error Handling



* Spring Boot ofrece soporte para los contenedores embebidos com o Tomcat o Jetty escuchando 8080

(Eligiendo el starter adecuado)

*  Servlets and Filters por defecto solo levanta un servlet mapeado '/' aunque se pueden definikr varios Servlet o Filter como Spring Beans


* Customizar el Servidor embebido

Definiendo el el aplication.properties

	. server.port — The listen port for incoming HTTP requests.
	. server.address — The interface address to bind to.
	. server.sessionTimeout — A session timeout.
	. server.contextPath

	(ServerProperties contiene la lista de parametros)

* Configuracion programatica

@Component
public class CustomizationBean implements EmbeddedServletContainerCustomizer {

    @Override
    public void customize(ConfigurableEmbeddedServletContainer container) {
        container.setPort(9000);
    }

}

O configurar directamente la instancia relativa al Tomcat (TomcatEmbeddedServletContainerFactory) o Jetty (JettyEmbeddedServletContainerFactory)

@Bean
public EmbeddedServletContainerFactory servletContainer() {
    TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory();
    factory.setPort(9000);
    factory.setSessionTimeout(10, TimeUnit.MINUTES);
    factory.addErrorPages(new ErrorPage(HttpStatus.404, "/notfound.html");
    return factory;
}






=========
SEGURIDAD
=========

Si spring security esta en el classpath la aplicacion web contendra autenticacion basica protegiendo todas las HTTP

AutenticationManager con un usuario 'user' password aleatoria que saldra en el log de la aplicacion

Se puede configurar con el parametro security.user.password (Mirar SecurityProperties)

Valores por defecto:

	. An AuthenticationManager bean with in-memory store and a single user (see SecurityProperties.User for the properties of the user).
	. Ignored (unsecure) paths for common static resource locations (/css/**, /js/**, /images/** and **/favicon.ico).
	. HTTP Basic security for all other endpoints.
	. Security events published to Spring’s ApplicationEventPublisher (successful and unsuccessful authentication and access denied).
	. Common low-level features (HSTS, XSS, CSRF, caching) provided by Spring Security are on by default.



. Se puede usar una configuracion propia de seguridad añadiendo @EnableWebSecurity usando ficheros externos y bean de tipo WebConfigurerAdapter

=========
BBDD
========

. Spring Boot proporciona un amplio soporte pra trabajar con BBDD

. Acceso directo por JDBC JdbcTemplate
. HIbernate
. Spring Data --> Creando implementaciones de Repository desde interfaces y usando convenciones para generar consultas desde el nombre de los metodos.

*  Configure a DataSource

* EMbebedd BBDD

Ofrece soporte para H2, HSQL and Derby databases solo con añadir su dependencia

	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
	    <groupId>org.hsqldb</groupId>
	    <artifactId>hsqldb</artifactId>
	    <scope>runtime</scope>
	</dependency>

The “How-to” section includes a section on how to initialize a database

Podemos configurar un datasource a partir del fichero de configuracion

spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
See DataSourceProperties for more of the supported options.

spring.datasource.driver-class No es necesario ya que Spring Boot lo deduce a partir de la URL de conexion

* Connection to a JNDI DataSource

spring.datasource.jndi-name=java:jboss/datasources/customers


* Usando JdbcTemplate

Se configura automaticamente y solo necesitamos inyectarlas con @Autowired:

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.JdbcTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

	    private final JdbcTemplate jdbcTemplate;

	    @Autowired
	    public MyBean(JdbcTemplate jdbcTemplate) {
	        this.jdbcTemplate = jdbcTemplate;
	    }

	    // ...

	}


* JPA and “Spring Data” --> spring-boot-starter-data-jpa --> Mirar Ejemplo

	. Hibernate — One of the most popular JPA implementations.
	. Spring Data JPA — Makes it easy to easily implement JPA-based repositories.
	. Spring ORMs — Core ORM support from the Spring Framework.

* Entity Classes

. Normalmente Entity son especificadas en un persistence.xml
* Con Spring Boot no es necesario, se escanearan por defecto todos los paquetes debajo de la clase principal de configuracion (El anotado con @EnableAutoConfiguration)

* Para personalizarlo se puede usar @EntityScan 

* Spring Data JPA Repositories


* 26.3.3 Creating and dropping JPA databases

By default JPA database will be automatically created only if you use an embedded database (H2, HSQL or Derby). You can explicitly configure JPA settings using spring.jpa.* properties. For example, to create and drop tables you can add the following to your application.properties.

spring.jpa.hibernate.ddl-auto=create-drop


======
NO-SQL
======

. Spring-Boot proporciona mecanismos para configurar automaticamente Spring Data para trabajar con Spring Boot provides auto-configuration for Redis, MongoDB, Elasticsearch, Solr and Gemfire;


* MONGO DB

spring-boot-starter-data-mongodb “Starter POM”.

Puedes inyectar un auto-configurado com.mongodb.Mongo a cualquier Spring Bean. Intentara conecctarse por defecto a a MongoDB server using the URL mongodb://localhost/test

Puedes definir la url spring.data.mongodb.uri

spring.data.mongodb.host=mongoserver
spring.data.mongodb.port=27017

Tambien puedes definir tu propio MOngo con @Bean para tener el control de la conexion con momgodb

Spring Data tiene MongoTemplate

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.data.mongodb.core.©;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

	    private final MongoTemplate mongoTemplate;

	    @Autowired
	    public MyBean(MongoTemplate mongoTemplate) {
	        this.mongoTemplate = mongoTemplate;
	    }

	    // ...

	}


* Ofrece el mismo soporte para Repositorios que con JPA Spring Data MongoDB repositories


========
JMS
========

- Spring Boot configura la infraestructura necesaria para el soporte de JMS

- HornetQ support

- ActiveMQ support

	. Configura una ConnectionFactory cuando detecta ACTIVEMQ IN THE CLASSPATH
	. Levanta un servidor embbebido

	. Se puede conectar con un servidor externo

	spring.activemq.broker-url=tcp://192.168.1.210:9876
	spring.activemq.user=admin
	spring.activemq.password=secret

	. Mas opciones ActiveMQProperties for more of the supported options.

	* JmsTemplate y JmsMessagingTemplate (new in Spring 4.1) can be injected in a similar manner.

	@Component
	public class MyBean {

	    private final JmsTemplate jmsTemplate;

	    @Autowired
	    public MyBean(JmsTemplate jmsTemplate) {
	        this.jmsTemplate = jmsTemplate;
	    }

	    // ...

	}

	* Recibiendo un Mensaje

	any bean can be annotated with @JmsListener to create a listener endpoint.

	@Component
	public class MyBean {

	    @JmsListener(destination = "someQueue")
	    public void processMessage(String content) { ... }

	}


==========
TEST
==========

. Boot proporciona una serie de herramientas para Testing

. spring-boot-starter-test

Incluye las dependencias a :

	- Spring Test — integration test support for Spring applications.
	- Junit — The de-facto standard for unit testing Java applications.
	- Hamcrest — A library of matcher objects (also known as constraints or predicates) allowing assertThat style JUnit assertions.
	- Mockito — A Java mocking framework.

@SpringApplicationConfiguration alternativa a @ContextConfiguration --> para conseguir las caracteristicas de Spring Boot

	@RunWith(SpringJUnit4ClassRunner.class)
	@SpringApplicationConfiguration(classes = SampleDataJpaApplication.class)
	public class CityRepositoryIntegrationTests {

	    @Autowired
	    CityRepository repository;

	    // ...

	}


-- REVISAR ---


====================
SPRING BOOT ACTUATOR
====================

Part V. Spring Boot Actuator: Production-ready features

Spring Boot includes a number of additional features to help you monitor and manage your application when it’s pushed to production. You can choose to manage and monitor your application using HTTP endpoints, with JMX or even by remote shell (SSH or Telnet). Auditing, health and metrics gathering can be automatically applied to your application.



Parte V. Primavera Boot actuador: características listas para la producción

Primavera Boot incluye una serie de características adicionales para ayudar a controlar y administrar su aplicación cuando es empujado a la producción. Usted puede elegir para administrar y supervisar su aplicación utilizando extremos HTTP, con JMX o incluso por remote shell (SSH o Telnet). Auditoría, la salud y las métricas de recolección se pueden aplicar automáticamente a su aplicación.


Spring Boot añade una serie de caracteristicas adicionales para ayudar a controlar y monitorizar la aplicacion

Entre ellas

– /health mostrará el estado de salud de la aplicación.
– /info mostrará información del proyecto (incluído el branch/commit de Git).
– /dump mostrará un dump de todos los threads.
– /beans mostrará todos los beans del ApplicationContext
- /autoconfig Muestra un oinforme con todas las auto-configuraciones disponibles y la razaon de pq se aplican o no
- /beans Lista de los beasn manejados por Spring
- /configprops Lista de los @ConfigurationProperties
- /env Lista las propiedades registradas Spring’s ConfigurableEnvironment.
- /metrics Muestra informacion de las metricas del proyecto
- /mappings Lista de los @RequestMapping path
- /shutdown Permite realizar un shutdown de la aplicacion
- /trace Información de traza , por defecto las ultimas peticiones HTTP


Estos endpoint se pueden personalizar desde el application.properties

endpoints.beans.id=springbeans
endpoints.beans.sensitive=false
endpoints.shutdown.enabled=true  --> Activo el shutdown


. Se puede personalizar el /health para ver si la conexion a BBDD funciona (DataSourceHealthIndicator ) o si servicios rest estan activos


import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyHealth implements HealthIndicator {

    @Override
    public Health health() {
        // perform some specific health check
        return ...
    }

}


. Personalizar /info Añadiendo datos al application.properties con el prefijo info.*

info.app.name=MyService
info.app.description=My awesome service
info.app.version=1.0.0



. Se puede personalizar el contextPath de los endpoint

management.context-path=/manage     -->  accederiamos /manage/info, /manage/trace, ....

. Personalizar el puerto 

management.port=8081

. La direccion

 management.address=127.0.0.1


 Desactivar Los endPoint management.port=-1


 GESTION POR JMX


 /Metrics devuelven informacion sobre memory, heap, class loading, processor and thread pool information along with some HTTP metrics.

 {
    "counter.status.200.root": 20,  --> Peticiones 
    "counter.status.200.metrics": 3, --> Peticiones a /metrics
    "counter.status.200.**": 5, --> Peticiones a recursos estaticos
    "counter.status.401.root": 4, --> Accesos no autorizados
    "gauge.response.**": 6, --> TIempos de respuesta
    "gauge.response.root": 2,
    "gauge.response.metrics": 3,
    "classes": 5808,
    "classes.loaded": 5808,
    "classes.unloaded": 0,
    "heap": 3728384,
    "heap.committed": 986624,
    "heap.init": 262144,
    "heap.used": 52765,
    "mem": 986624,
    "mem.free": 933858,
    "processors": 8,
    "threads": 15,
    "threads.daemon": 11,
    "threads.peak": 15,
    "uptime": 494836,
    "instance.uptime": 489782,
    "datasource.primary.active": 5,
    "datasource.primary.usage": 0.25
}


. Metricas DSatasource

The maximum number connections (datasource.xxx.max).
The minimum number of connections (datasource.xxx.min).
The number of active connections (datasource.xxx.active)
The current usage of the connection pool (datasource.xxx.usage).


. Crear tus propias metricas inyectando CounterService o GaugeService

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.metrics.CounterService;
import org.springframework.stereotype.Service;

@Service
public class MyService {

    private final CounterService counterService;

    @Autowired
    public MyService(CounterService counterService) {
        this.counterService = counterService;
    }

    public void exampleMethod() {
        this.counterService.increment("services.system.myservice.invoked");
    }

}

GaugeService revisar y crear ejemplo

@RestController
@RequestMapping("/user")
@EnableAutoConfiguration
class UserController {

  @Autowired
  UserRepository repository

  @Autowired
  GaugeService gaugeService

  @Value('${application.metrics.dbExecutionTimeKey}')
  String dbExecutionKey

  @RequestMapping(method=[RequestMethod.GET])
  def get(Long id) {
    def start = new Date().time
    def result = id ? repository.findOne(id) : repository.findAll()
    gaugeService.submit dbExecutionKey, new Date().time - start
    result
  }

  public static void main(String[] args) {
    SpringApplication.run UserController, args
  }
}


* Se pueden añadir las metricas Coda Hale Metrics incluyendo su libreria entre las dependencias del proyecto.

* /trace tracea las peticiones HTTP

	- Se pueden customizar para añadir nuestras trazas inyectando TraceRepository en los Spring BEans

	- By default an InMemoryTraceRepository will be used that stores the last 100 events. You can define your own instance of the InMemoryTraceRepository bean if you need to expand the capacity


* Auditoria --> Spring Security --> Se podrian añadir alguna propio


OJO PARA LEVANTARLO EN DEBUG new SpringApplicationBuilder(MyConfig.class).run(new String[]{"--debug"});









































	



